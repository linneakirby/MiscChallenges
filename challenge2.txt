Linnea Kirby
21 June 2016

Solution for Cipher Tech Solutions Challenge 2

There are a few key components to constructing our desired database-creator. First, and arguably most importantly, we need to be able to extract the specified data point formats. We can easily accomplish this task by using regular expressions. Regular expressions allow us to abstract our data point formats into patterns. For example, we know phone numbers will always be in the pattern of: three digits, a hyphen, three digits, a hyphen, four digits. We can easily write this pattern as a regular expression like so: \d\d\d-\d\d\d-\d\d\d\d. 

Once we have all our regular expressions for our data point formats, we need somewhere to store them. I argue that a hashmap is the best data structure for this task, as it maps keys to values and performs get and put in constant time. Therefore, to continue our example, it would be simple to map "Phone" to "\d\d\d-\d\d\d-\d\d\d\d" in our regular expressions hashmap. Using a hashmap also allows us to easily add new data point formats, update formats, and delete formats. Java's HashMap class, for example, has put(key, value), replace(key, value), and remove(key) which directly map onto our desired functions. Once our hashmap exists, no recompilation is necessarily to perform any of these changes. We simply need functions that respond to user-inputted keywords, such as "remove Phone," which would indicate to our program to remove the key "Phone" from our hashmap. Furthermore, if we want more than one regular expression to map onto a particular data point format, we can simply store our regular expressions in a list, such as an array list or linked list and put those into our hashmap. This decision would need to be made before compilation, however.

Now that we know how to store our data point formats, we need to be able to find our data points. Therefore, we need a scanner that will scan through our HTML documents and compare sections of the documents to all the regular expressions stored in our hashmap. IP addresses, 10 digit phone numbers, email addresses, and URLs do not contain spaces, so we can simply look at each word in each file to see if any of our regular expressions match. Proper names are slightly more difficult, as, like sentences, they begin with an uppercase letter. However, proper names are usually more than one word, so if our scanner finds a capitalized word, we can simply have it look at the next word. If the next word is also capitalized, then we know we have a proper name. Of course, proper names may contain more than two words, but it is trivial to have our scanner find the maximum number of capitalized words in a row. Again, our regular expressions will reflect this pattern.

Identifying data points in tables is trivial, and is even easier than identifying them in basic text. In basic text, we could ignore any HTML tags. In tables, the HTML tags are helpful, as they help us identify labels that we might have used for our hashmap, thereby indicating what format our data point might be. <table> indicates the beginning of a table, and <tr> indicates the beginning of a table row. After the first <tr>, we will be able to easily extract the column labels. In the example provided, "Name" is the label given to the first column. From that, our program would then look at the first paragraph, indicated by a <p>, nested in each subsequent <tr> and would check to see if it matched to the regular expression matched with "Name" in our hashmap. If our hashmap does not contain "Name (perhaps we used "proper name" as our key instead), then our program would simply go through all entries in the hashmap to see if any of them matched. Therefore, tables provide clues as to what type of data point we are looking at, and so may increase the efficiency of our program.

Once we have found a data point, we need to output what we have found. Since our program is not building the database itself, we can simply print out any discovered data points. A simple format would be to print out the type of data point found (i.e. the key from our hashmap) and then the found data point. So, for example, if our program found the phone number "781-488-8018," which matches the value "\d\d\d-\d\d\d-\d\d\d\d" mapped to the key "Phone," it would output "Phone: 781-488-8018." 

We could also have our program attempt to group output into related data points, though the accuracy would depend on how close in proximity related data points appear. A simple method would be to output data points found in the same sentence or same row in a table on one line, such as "Name: Linnea Kirby, Phone: 781-488-8018." Again, this method may not be the most accurate, as related data points may be found in different sentences and unrelated data points may sometimes be found in the same sentence. 